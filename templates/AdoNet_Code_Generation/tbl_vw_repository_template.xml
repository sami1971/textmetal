<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2012 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v4.4.0">

	<OutputScope name="${ClrNamespace}\Repository.tv.g.cs">
		<Include name="include_gen_cprt_message.cs.txt" />
<![CDATA[

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;

using TextMetal.Plumbing.CommonFacilities;
]]>
		<If>
			<If.Condition>
				<UnaryExpression operator="IsDef">
					<UnaryExpression.TheExpression>
						<Aspect name="ClrUsingNamespaces" />
					</UnaryExpression.TheExpression>
				</UnaryExpression>
			</If.Condition>
			<If.True>
				<ForEach in="ClrUsingNamespaces" var-ct="#LoopCount" var-ix="#LoopIndex" var-item="#item">
					<ForEach.Body>
						<![CDATA[using ${#item};
]]>
					</ForEach.Body>
				</ForEach>
			</If.True>
		</If>

		<If>
			<If.Condition>
				<BinaryExpression operator="Or">
					<BinaryExpression.LeftExpression>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="HasTables" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="HasViews" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[
]]>
			</If.True>
		</If>

		<If>
			<If.Condition>
				<BinaryExpression operator="Eq">
					<BinaryExpression.LeftExpression>
						<Value type="System.Boolean" data="True" />
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<Facet name="HasTables" />
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[using ${ClrNamespace}.Tables;
]]>
			</If.True>
		</If>
		<If>
			<If.Condition>
				<BinaryExpression operator="Eq">
					<BinaryExpression.LeftExpression>
						<Value type="System.Boolean" data="True" />
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<Facet name="HasViews" />
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[using ${ClrNamespace}.Views;
]]>
			</If.True>
		</If>
		<![CDATA[
namespace ${ClrNamespace}
{
	public partial class Repository
	{		
		#region Methods/Operators
		
		protected bool PersistModel<TModel>(UnitOfWorkContext unitOfWorkContext, TModel model, CommandType commandType, string commandText, IList<IDataParameter> commandParameters, int persistNotExpectedRecordsAffected, Action<IDictionary<string, object>, TModel> mapToCallback)
			where TModel : class, new()
		{
			int recordsAffected;
			IList<IDictionary<string, object>> results;

			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");

			if ((object)model == null)
				throw new ArgumentNullException("model");

			if ((object)commandText == null)
				throw new ArgumentNullException("commandText");

			if ((object)commandParameters == null)
				throw new ArgumentNullException("commandParameters");

			if ((object)mapToCallback == null)
				throw new ArgumentNullException("mapToCallback");

			if (DataType.IsNullOrWhiteSpace(commandText))
				throw new ArgumentOutOfRangeException("commandText");
			
			OnProfileCommand(typeof(TModel), commandType, commandText, commandParameters, true, persistNotExpectedRecordsAffected);
			
			results = unitOfWorkContext.ExecuteDictionary(commandType, commandText, commandParameters, out recordsAffected);

			if (recordsAffected <= persistNotExpectedRecordsAffected)
			{
				// concurrency failure
				unitOfWorkContext.Divergent();
				return false;
			}

			if ((object)results == null)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			if (results.Count == 1)
				mapToCallback(results[0], model);
			
			return true;
		}
		
		protected IList<TModel> QueryModel<TModel>(UnitOfWorkContext unitOfWorkContext, CommandType commandType, string commandText, IList<IDataParameter> commandParameters, int queryExpectedRecordsAffected, Action<IDictionary<string, object>, TModel> mapToCallback)
			where TModel : class, new()
		{
			IList<TModel> models;
			TModel model;
			int recordsAffected;
			IList<IDictionary<string, object>> results;

			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");

			if ((object)commandText == null)
				throw new ArgumentNullException("commandText");

			if ((object)commandParameters == null)
				throw new ArgumentNullException("commandParameters");

			if ((object)mapToCallback == null)
				throw new ArgumentNullException("mapToCallback");

			if (DataType.IsNullOrWhiteSpace(commandText))
				throw new ArgumentOutOfRangeException("commandText");

			OnProfileCommand(typeof(TModel), commandType, commandText, commandParameters, false, queryExpectedRecordsAffected);
			
			results = unitOfWorkContext.ExecuteDictionary(commandType, commandText, commandParameters, out recordsAffected);

			if (recordsAffected != queryExpectedRecordsAffected)
			{
				// idempotency failure
				unitOfWorkContext.Divergent();
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");
			}

			if ((object)results == null)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			models = new List<TModel>();

			foreach (IDictionary<string, object> result in results)
			{
				model = new TModel();
				mapToCallback(result, model);
				models.Add(model);
			}

			return models;
		}
		
		protected TModel FetchModel<TModel>(UnitOfWorkContext unitOfWorkContext, CommandType commandType, string commandText, IList<IDataParameter> commandParameters, int queryExpectedRecordsAffected, Action<IDictionary<string, object>, TModel> mapToCallback)
			where TModel: class, new()
		{
			TModel model;
			int recordsAffected;
			IList<IDictionary<string, object>> results;
						
			if ((object)unitOfWorkContext == null)		
				throw new ArgumentNullException("unitOfWorkContext");
			
			if ((object)commandText == null)
				throw new ArgumentNullException("commandText");
				
			if ((object)commandParameters == null)
				throw new ArgumentNullException("commandParameters");
				
			if ((object)mapToCallback == null)
				throw new ArgumentNullException("mapToCallback");

			if (DataType.IsNullOrWhiteSpace(commandText))
				throw new ArgumentOutOfRangeException("commandText");
			
			OnProfileCommand(typeof(TModel), commandType, commandText, commandParameters, false, queryExpectedRecordsAffected);
			
			results = unitOfWorkContext.ExecuteDictionary(commandType, commandText, commandParameters, out recordsAffected);
			
			if (recordsAffected != queryExpectedRecordsAffected)
			{
				// idempotency failure
				unitOfWorkContext.Divergent();
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");
			}
				
			if ((object)results == null)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			if (results.Count != 1)
				return null;

			model = new TModel();

			mapToCallback(results[0], model);

			return model;
		}
		
		protected void FillModel<TModel>(UnitOfWorkContext unitOfWorkContext, TModel model, CommandType commandType, string commandText, IList<IDataParameter> commandParameters, int queryExpectedRecordsAffected, Action<IDictionary<string, object>, TModel> mapToCallback)
			where TModel: class, new()
		{
			int recordsAffected;
			IList<IDictionary<string, object>> results;
						
			if ((object)unitOfWorkContext == null)		
				throw new ArgumentNullException("unitOfWorkContext");
			
			if ((object)model == null)
				throw new ArgumentNullException("model");
				
			if ((object)commandText == null)
				throw new ArgumentNullException("commandText");
				
			if ((object)commandParameters == null)
				throw new ArgumentNullException("commandParameters");
				
			if ((object)mapToCallback == null)
				throw new ArgumentNullException("mapToCallback");

			if (DataType.IsNullOrWhiteSpace(commandText))
				throw new ArgumentOutOfRangeException("commandText");
			
			OnProfileCommand(typeof(TModel), commandType, commandText, commandParameters, false, queryExpectedRecordsAffected);
			
			results = unitOfWorkContext.ExecuteDictionary(commandType, commandText, commandParameters, out recordsAffected);
			
			if (recordsAffected != queryExpectedRecordsAffected)
			{
				// idempotency failure
				unitOfWorkContext.Divergent();
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");
			}
				
			if ((object)results == null)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			if (results.Count != 1)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			mapToCallback(results[0], model);
		}
		
]]>

		<ForEach in="Schemas" var-ct="#LoopCount" var-ix="#LoopIndex">			
			<ForEach.Body>
				
				<ForEach in="Tables" var-ct="#LoopCount" var-ix="#LoopIndex">
					<ForEach.Body>
						<![CDATA[		public ${TableNameSingularPascalCase} Load${TableNameSingularPascalCase}(]]>
						<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsPrimaryKey" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="True" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[${ColumnCSharpClrType} ${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="#LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="#LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[)
		{
			${TableNameSingularPascalCase} retval;
						
			retval = this.ExecuteAmbientUnitOfWorkAware((uowc, ]]>
						<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsPrimaryKey" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="True" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[p${#LoopIndex}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="#LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="#LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[) => this.Load${TableNameSingularPascalCase}(uowc, ]]>
						<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsPrimaryKey" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="True" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[p${#LoopIndex}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="#LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="#LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[), ]]>
						<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsPrimaryKey" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="True" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="#LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="#LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[);
			
			return retval;
		}
		
]]>
				
<![CDATA[		public ${TableNameSingularPascalCase} Load${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ]]>
						<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsPrimaryKey" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="True" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[${ColumnCSharpClrType} ${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="#LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="#LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[)
		{			
			${TableNameSingularPascalCase} ${TableNameSingularCamelCase};			
			IDataParameter commandParameter;
			List<IDataParameter> commandParameters;
			string commandText;
			int queryExpectedRecordsAffected;
			
			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");

			commandParameters = new List<IDataParameter>();
			
]]>
	<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Filter>
			<BinaryExpression operator="Eq">
				<BinaryExpression.LeftExpression>
					<Facet name="ColumnIsPrimaryKey" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[			commandParameter = unitOfWorkContext.CreateParameter(ParameterDirection.Input, DbType.${ColumnDbType}, ${ColumnSize}, ${ColumnPrecision}, ${ColumnScale}, ${ColumnCSharpNullableLiteral}, ConnectionSpecificGetParameterName(${TableNameSingularPascalCase}.COLUMN_NAME_${ColumnNameConstantCase}), ${ColumnNameCamelCase});
			commandParameters.Add(commandParameter);
			ConnectionSpecificParameterMagic(unitOfWorkContext, commandParameter, "${ColumnSqlType}");]]>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

]]>
				</If.True>
			</If>
		</ForEach.Body>
	 </ForEach>
<![CDATA[

			]]>
			<Import name="import_selectone.xml" />
<![CDATA[			
			
			ConnectionSpecificCommandMagic(unitOfWorkContext, false, out queryExpectedRecordsAffected);
			
			${TableNameSingularCamelCase} = this.FetchModel<${TableNameSingularPascalCase}>(unitOfWorkContext, CommandType.Text, commandText, commandParameters, queryExpectedRecordsAffected, MapTo${TableNameSingularPascalCase});
							
			this.OnSelect${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});

			return ${TableNameSingularCamelCase};
		}
		
		public IList<${TableNameSingularPascalCase}> Find${TableNamePluralPascalCase}(Query ${TableNameSingularCamelCase}Query)
		{
			IList<${TableNameSingularPascalCase}> retval;
			
			retval = this.ExecuteAmbientUnitOfWorkAware((uowc, q) => this.Find${TableNamePluralPascalCase}(uowc, q), ${TableNameSingularCamelCase}Query);
			
			return retval;
		}
		
		public IList<${TableNameSingularPascalCase}> Find${TableNamePluralPascalCase}(UnitOfWorkContext unitOfWorkContext, Query ${TableNameSingularCamelCase}Query)
		{
			IList<${TableNameSingularPascalCase}> ${TableNamePluralCamelCase};			
			List<IDataParameter> commandParameters;
			string commandText, filterFragment, sortFragment;
			int queryExpectedRecordsAffected;
			
			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");
				
			if ((object)${TableNameSingularCamelCase}Query == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}Query");	
			
			if ((object)${TableNameSingularCamelCase}Query.Orders == null)
				throw new InvalidOperationException("TODO (enhancement): add meaningful message");

			commandParameters = new List<IDataParameter>();
			
			filterFragment = SqlExpressionVisitor.GetFilterText(unitOfWorkContext, commandParameters, ${TableNameSingularCamelCase}Query.Expression);
			sortFragment = SqlExpressionVisitor.GetSortText(unitOfWorkContext, commandParameters, ${TableNameSingularCamelCase}Query.Orders);

			]]>
			<Import name="import_selectfor.xml" />
<![CDATA[
			commandText = string.Format(commandText, filterFragment, sortFragment);
			
			ConnectionSpecificCommandMagic(unitOfWorkContext, false, out queryExpectedRecordsAffected);
			
			${TableNamePluralCamelCase} = this.QueryModel<${TableNameSingularPascalCase}>(unitOfWorkContext, CommandType.Text, commandText, commandParameters, queryExpectedRecordsAffected, MapTo${TableNameSingularPascalCase});			
			
			foreach (${TableNameSingularPascalCase} ${TableNameSingularCamelCase} in ${TableNamePluralCamelCase})
				this.OnSelect${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
							
			return ${TableNamePluralCamelCase};
		}
		
		public bool Save${TableNameSingularPascalCase}(${TableNameSingularPascalCase} ${TableNameSingularCamelCase})
		{
			bool retval;
			
			retval = this.ExecuteAmbientUnitOfWorkAware((uowc, e) => this.Save${TableNameSingularPascalCase}(uowc, e), ${TableNameSingularCamelCase});
			
			return retval;
		}
		
		public bool Save${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase})
		{
			IDataParameter commandParameter;
			List<IDataParameter> commandParameters;
			string commandText;
			int persistNotExpectedRecordsAffected, queryExpectedRecordsAffected;
			bool wasNew, retval;
			
			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");
			
			if ((object)${TableNameSingularCamelCase} == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}");
			
			wasNew = ${TableNameSingularCamelCase}.IsNew;
			
			commandParameters = new List<IDataParameter>();
			
			if (wasNew)
			{	
				this.OnPreInsert${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
				
]]>

	<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Filter>
			<BinaryExpression operator="Ne">
				<BinaryExpression.LeftExpression>
					<Facet name="ColumnIsIdentity" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[				commandParameter = unitOfWorkContext.CreateParameter(ParameterDirection.Input, DbType.${ColumnDbType}, ${ColumnSize}, ${ColumnPrecision}, ${ColumnScale}, ${ColumnCSharpNullableLiteral}, ConnectionSpecificGetParameterName("${ColumnNamePascalCase}"), ${TableNameSingularCamelCase}.${ColumnNamePascalCase});
				commandParameters.Add(commandParameter);
				ConnectionSpecificParameterMagic(unitOfWorkContext, commandParameter, "${ColumnSqlType}");]]>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

]]>
				</If.True>
			</If>
		</ForEach.Body>
	</ForEach>

			
<![CDATA[

				]]>
				<Import name="import_insert.xml" />
<![CDATA[
			
				ConnectionSpecificCommandMagic(unitOfWorkContext, true, out persistNotExpectedRecordsAffected);
			}
			else
			{
				this.OnPreUpdate${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
				
]]>

	<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Filter>
			<BinaryExpression operator="And">
				<BinaryExpression.LeftExpression>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsIdentity" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsPrimaryKey" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[				commandParameter = unitOfWorkContext.CreateParameter(ParameterDirection.Input, DbType.${ColumnDbType}, ${ColumnSize}, ${ColumnPrecision}, ${ColumnScale}, ${ColumnCSharpNullableLiteral}, ConnectionSpecificGetParameterName(${TableNameSingularPascalCase}.COLUMN_NAME_${ColumnNameConstantCase}), ${TableNameSingularCamelCase}.${ColumnNamePascalCase});
				commandParameters.Add(commandParameter);
				ConnectionSpecificParameterMagic(unitOfWorkContext, commandParameter, "${ColumnSqlType}");]]>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

]]>
				</If.True>
			</If>
		</ForEach.Body>
	</ForEach>

<![CDATA[

]]>	
	
	<ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Filter>
			<BinaryExpression operator="Or">
				<BinaryExpression.LeftExpression>
					<BinaryExpression operator="Eq">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsIdentity" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<BinaryExpression operator="Eq">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsPrimaryKey" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[				commandParameter = unitOfWorkContext.CreateParameter(ParameterDirection.Input, DbType.${ColumnDbType}, ${ColumnSize}, ${ColumnPrecision}, ${ColumnScale}, ${ColumnCSharpNullableLiteral}, ConnectionSpecificGetParameterName(${TableNameSingularPascalCase}.COLUMN_NAME_${ColumnNameConstantCase}), ${TableNameSingularCamelCase}.${ColumnNamePascalCase});
				commandParameters.Add(commandParameter);
				ConnectionSpecificParameterMagic(unitOfWorkContext, commandParameter, "${ColumnSqlType}");]]>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

]]>
				</If.True>
			</If>
		</ForEach.Body>
	</ForEach>

			
<![CDATA[

				]]>
				<Import name="import_update.xml" />
<![CDATA[
				
				ConnectionSpecificCommandMagic(unitOfWorkContext, true, out persistNotExpectedRecordsAffected);
			}			
			
			retval = this.PersistModel<${TableNameSingularPascalCase}>(unitOfWorkContext, ${TableNameSingularCamelCase}, CommandType.Text, commandText, commandParameters, persistNotExpectedRecordsAffected, MapTo${TableNameSingularPascalCase});
		
			if (!retval)
				return retval;
			
			commandParameters.Clear();
			]]>
			<Import name="import_identity.xml" />
<![CDATA[
				
			ConnectionSpecificCommandMagic(unitOfWorkContext, false, out queryExpectedRecordsAffected);
				
			if (wasNew && !DataType.IsNullOrWhiteSpace(commandText))
			{
				// select the identity on the same connection
				this.FillModel<${TableNameSingularPascalCase}>(unitOfWorkContext, ${TableNameSingularCamelCase}, CommandType.Text, commandText, commandParameters, queryExpectedRecordsAffected, MapTo${TableNameSingularPascalCase});
			}
			
			if (wasNew)
			{
				this.OnPostInsert${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
			}
			else
			{
				this.OnPostUpdate${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
			}			

			return retval;
		}
		
		public bool Discard${TableNameSingularPascalCase}(${TableNameSingularPascalCase} ${TableNameSingularCamelCase})
		{
			bool retval;
			
			retval = this.ExecuteAmbientUnitOfWorkAware((uowc, e) => this.Discard${TableNameSingularPascalCase}(uowc, e), ${TableNameSingularCamelCase});
			
			return retval;
		}
		
		public bool Discard${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase})
		{
			IDataParameter commandParameter;
			List<IDataParameter> commandParameters;
			string commandText;
			int persistNotExpectedRecordsAffected;
			bool retval;
			
			if ((object)unitOfWorkContext == null)
				throw new ArgumentNullException("unitOfWorkContext");
			
			if ((object)${TableNameSingularCamelCase} == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}");
			
			if (${TableNameSingularCamelCase}.IsNew)
				return true;
				
			commandParameters = new List<IDataParameter>();			
						
]]><ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Filter>
			<BinaryExpression operator="Or">
				<BinaryExpression.LeftExpression>
					<BinaryExpression operator="Eq">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsIdentity" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<BinaryExpression operator="Eq">
						<BinaryExpression.LeftExpression>
							<Facet name="ColumnIsPrimaryKey" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.Boolean" data="True" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[			commandParameter = unitOfWorkContext.CreateParameter(ParameterDirection.Input, DbType.${ColumnDbType}, ${ColumnSize}, ${ColumnPrecision}, ${ColumnScale}, ${ColumnCSharpNullableLiteral}, ConnectionSpecificGetParameterName(${TableNameSingularPascalCase}.COLUMN_NAME_${ColumnNameConstantCase}), ${TableNameSingularCamelCase}.${ColumnNamePascalCase});
			commandParameters.Add(commandParameter);
			ConnectionSpecificParameterMagic(unitOfWorkContext, commandParameter, "${ColumnSqlType}");]]>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

]]>
				</If.True>
			</If>
		</ForEach.Body>
	 </ForEach>
<![CDATA[

			this.OnPreDelete${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});

			]]>
			<Import name="import_delete.xml" />
<![CDATA[
			
			ConnectionSpecificCommandMagic(unitOfWorkContext, true, out persistNotExpectedRecordsAffected);
			
			retval = this.PersistModel<${TableNameSingularPascalCase}>(unitOfWorkContext, ${TableNameSingularCamelCase}, CommandType.Text, commandText, commandParameters, persistNotExpectedRecordsAffected, MapTo${TableNameSingularPascalCase});

			this.OnPostDelete${TableNameSingularPascalCase}(unitOfWorkContext, ${TableNameSingularCamelCase});
						
			${TableNameSingularCamelCase}.IsNew = false;

			return retval;
		}
		
		private static void MapTo${TableNameSingularPascalCase}(IDictionary<string, object> result, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase})
		{
			object value;
			
			if ((object)result == null)
				throw new ArgumentNullException("result");
				
			if ((object)${TableNameSingularCamelCase} == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}");
			
]]><ForEach in="Columns" var-ct="#LoopCount" var-ix="#LoopIndex">
		<ForEach.Body>
			<![CDATA[			if (result.TryGetValue("${ColumnNamePascalCase}", out value))
				${TableNameSingularCamelCase}.${ColumnNamePascalCase} = value.ChangeType<${ColumnCSharpClrNullableType}>();
]]>
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="#LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="#LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
					<![CDATA[
]]>
				</If.True>
			</If>
		</ForEach.Body>
	 </ForEach>
<![CDATA[		}
		
		partial void OnPreInsert${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnPostInsert${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnPreUpdate${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnPostUpdate${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnPreDelete${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnPostDelete${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});
		
		partial void OnSelect${TableNameSingularPascalCase}(UnitOfWorkContext unitOfWorkContext, ${TableNameSingularPascalCase} ${TableNameSingularCamelCase});		
]]>
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="#LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="#LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
								<![CDATA[
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>

			</ForEach.Body>
		</ForEach>

		<![CDATA[
		#endregion
	}
}
]]>
	</OutputScope>

</Template>